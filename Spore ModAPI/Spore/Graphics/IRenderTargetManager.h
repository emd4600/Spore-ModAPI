#pragma once

#include <Spore\Internal.h>
#include <Spore\resourceID.h>
#include <Spore\MathUtils.h>
#include <Spore\RenderWare\Raster.h>

/// Access the active render target manager.
#define RenderTargetManager (*Graphics::IRenderTargetManager::Get())

#define IRenderTargetManagerPtr eastl::intrusive_ptr<Graphics::IRenderTargetManager>

namespace Graphics
{
	class Texture;

	struct RenderTargetID
	{
		int index;
		int regionIndex;
	};

	class IRenderTargetManager
	{
	public:
		/* 00h */	virtual int AddRef() = 0;
		/* 04h */	virtual int Release() = 0;
		/* 08h */	virtual bool Initialize() = 0;
		/* 0Ch */	virtual bool Dispose() = 0;

		/// Creates a new render target manager. It returns the index and regionIndex that can be used to access that render target.
		/// This will also create a new texture using the ITextureManager, with the given `instanceID` as name (or autogenerated if not specified).
		/// @param width
		/// @param height
		/// @param format
		/// @param flags
		/// @param instanceID
		/// @returns Index and regionIndex of the new RTT
		/* 10h */	virtual struct RenderTargetID CreateRenderTarget(int width, int height, D3DFORMAT format, int flags = 0, uint32_t instanceID = 0xFFFFFFFF, int = 0) = 0;

		/* 14h */	virtual bool ReleaseRenderTarget(struct RenderTargetID index) = 0;
		
		//PLACEHOLDER
		// with 0x15, returns rendering RTT?
		/// Returns the render target raster stored with the given index. Region index is ignored
		/// @param index
		/// @returns
		/* 18h */	virtual RenderWare::Raster* GetRaster(struct RenderTargetID index) const = 0;

		/// Returns the render target texture stored with the given index. Region index is ignored
		/// @param index
		/// @returns
		/* 1Ch */	virtual Texture* GetTexture(struct RenderTargetID index) const = 0;

		/* 20h */	virtual bool GetRegionViewport(struct RenderTargetID index, Math::IntRectangle& dst);
		/* 24h */	virtual bool GetRegionViewport2(struct RenderTargetID index, int& dst_x1, int& dst_y1, int& dst_width, int& dst_height);
		/* 28h */	virtual bool GetRasterTotalDimensions(int index, int& dst_width, int& dst_height);
		/* 2Ch */	virtual bool GetRegionUVCoords(struct RenderTargetID index, Math::Vector2& dstTopLeft, Math::Vector2& dstBottomRight);
		// regionIndex is ignored
		/* 30h */	virtual void GetRenderTargetData(struct RenderTargetID index, void*& pDstData);
		/* 34h */	virtual void func34h(class ResourceID index, int, int);
		/* 38h */	virtual void func38h(int, int);  // does nothing
		/* 3Ch */	virtual bool func3Ch();  // does nothing, returns true
		/* 40h */	virtual bool func40h(int, int, int, int);  // does nothing, returns false
		/* 44h */	virtual void func44h();  // does nothing
		/* 48h */	virtual void SetRenderTargetName(struct RenderTargetID index, const char* pName);  // does nothing

		static IRenderTargetManager* Get();
		
	protected:
		// /* 18h */	eastl::vector<>
	};

	namespace Addresses(IRenderTargetManager) {
		DeclareAddress(Get);
	}
}

namespace Addresses(Graphics) {
	DeclareAddress(MainColorRTT_ptr);
	DeclareAddress(MainDepthRTT_ptr);
}

namespace Graphics
{
	inline RenderWare::Raster* GetMainColorRTT() {
		return *(RenderWare::Raster**)(GetAddress(Graphics, MainColorRTT_ptr));
	}

	inline RenderWare::Raster* GetMainDepthRTT() {
		return *(RenderWare::Raster**)(GetAddress(Graphics, MainDepthRTT_ptr));
	}
}